good morning again okay let's get this

started you excited to be here all right

very good

ah before I start my talk I want to

start off with some fun okay so I want

to show you guys the latest toy that we

have back in the office so if you see

right here this is a flying drone that's

remote-controlled this is a this is

actually Karen's drone that's flying I'm

filming this from my drone so we have

two drones actually flying in the office

right there there's Karen right there at

the edge we're trying to do the thing

where we're practicing flying so she's

going to fly around the room and I'm

going to fly so my camera points at her

all the time

lost in the lights there we go it's

coming out there I tell you this is

great fun it's it's really weird to see

people walking through our hallways at

the office and looking up and seeing

what's going on with us but so far

everybody's been very positive no one's

tried to get us kicked out because we're

flying drones but this is this is this

is awesome stuff and you just have great

fun I'm not going to make you watch the

entire video I'm going to skip ahead

here and I'll show you what happens when

your drone runs out of batteries so

there yeah about right here maybe okay

so I'm I'm filming and going around all

of a sudden I get a little bit wobbly

with my drone and there we go okay

lesson watch the battery meter when

you're flying okay, 

so that's the fun part we'll have more fun too, 
but I thought we just start off with that. 

# introduction
hi I'm Jim Wyrick.
I'm with neo.
and I'm here to talk about 'why you should be using Ruby'

now I think so I'm going to I'm going to

try to convince you that Ruby is a cool
language to use and that you should be
using it then and if you're not already.

how many people are here using Ruby?
already ok quite enough. 

how many people here are curious about Ruby and they
aren't using it yet? 

ok quite a number of you 
you are the guys I want to talk to 

I want to tell you about Ruby and get you

excited about maybe using it now there's

a downside to doing talks like this and

I think us as programmers fall into this

trap a lot

there's features versus benefits and

when I talk about features if I talk about Ruby. 

# blocks in ruby
I'd love to tell you about the blocks in Ruby.

how we can use anonymous blocks do all kinds of
wonderful things.

I can talk about the

strong oo messaging in Ruby.

and how great that is I can tell you that Ruby
is a dynamic language I can tell you
about the testing culture that comes

along with a community of Ruby but these

are all features of the language what

you really want to hear or what are the

benefits to you for using Ruby so I'm

not going to talk a lot about the

features of Ruby instead I'm going to

tell some stories so maybe a better name

for this talk instead of why aren't you

using Ruby is why I use Ruby so we're

going to go from there I'm going to tell

you 5 stories about some Ruby code that

I've written in the past that I get

excited about and I really love and the

first story is about me switching to

Ruby in the first place

only people recognize this code what

language Perl yes

Perl so I was I was using Perl at the

time this would have been the year 2000

probably in the spring I've been using

Perl for about 3 years to do a lot of

scripting I was a C++ programmer at the

time just learning Java during this time

period I use Perl to write a lot of the

scripts that I use to manage my process

to generate header files to find things

in files

sort things out just all the tools that

every programmer uses to get things done

I was writing my stuff in Perl now Perl

is a wonderful language to get things

done quickly in and I really really

loved it for that but there's a big

downside to using Perl and I found that

as my programs grew larger and larger

the Perl code became harder and harder

to manage as long as you need a list of

items in Perl that's awesome it works

great but as soon as you need a list of

a list things get a little strange in

Perl in fact I would like to point out

that in the Perl tutorial page there's a

separate document just talking about how

to write a list of a list and it is

called Perl lol not saying anything but

okay so I was using Perl I was really

really really looking for something

better so I surveyed the landscape and

in the year 2000 there wasn't much else

out there but I stumble along this other

language called Python good Python looks

like it's exactly what I need it's

object oriented which is something I

really really liked if you ever tried to

do object orientation in Perl Oh haven't

helped you it was a scripting language

and it was freely available to all the

criteria I needed so I grabbed Python I

started using it the immediate downside

I found is that where I could write

stuff very very very quickly in Perl to

do it in Python required me to go back

to the documentation and read how do I

read a file how do I do this how do I do

that and every single thing I needed to

do I had to look up and learn and so the

learning curve moving from pearl to

Python was rather steep for me in fact

it was steep enough I tried three

separate times to learn Python and gave

up two times the third time I was

determined I am going to learn this

language or else so I sat down I started

doing stuff with it and I was reading

the documentation and I was I was really

getting you know into Python and I was

really going to learn it and then I was

reading a mailing list I think it was

the extreme programming mailing list so

because XP was

in the year 2000 that was kind of when

it was kicking off and I was reading

that mailing list and there was a email
on that list from this fella: Dave Thomas, 
who wrote the 'pickaxe book'.

but at the time the only book he had written was the pragmatic programmer
which I had just finished reading. 
have
you read this book awesome book if you
have not read this book yet please go
out and pick it up it is full of really

great pragmatic advice for developers I

really highly recommend it so I said oh

look here's an email from Dave Thomas

and I really respect him because of the

book he wrote here and the email he said

hey guys I discovered this little

language called Ruby it's kind of cool

you might like it that's all he said I

thought well if Dave Thomas likes Ruby

I'm going to check it out

so I downloaded Ruby I booted it up

booted it up I started it up and I

started taking a look at it and in two

days

I totally switched from Perl to Ruby

after two days I wrote no more new code

in Perl after that point I switched over

was so easy for me every time I got to a

place where I said I need to do

something I would think about oh let's

see Perl doesn't like this if I would

take that and do it in a way I would do

it like this and bam it worked so Ruby

really matched match my expectations of

the language it was an awesome

experience and I love Ruby ever since

that so I've been using Ruby now

thirteen years getting really close to

thirteen years now so awesome awesome

awesome language so let's summarize this

story

Ruby has what we call the principle of

least surprise things in there if you

know the language and kind of knows know

where it's going this thing's did it

tend to be unsurprising you think hmm

how would I do this and doggone it it

seems to work

it has great data abstraction where Perl

had trouble managing lists of lists Ruby

could easily handle lists of anything

and it was just objects and everything

was uniformly accessed through through

message passing and it was so strong

strongly oh-oh in fact it's probably the

most low language out there in the same

class as small talk so a really strong

ability and easy to learn I found it

quite easy to pick up and go with it

I teach rails programming now to people

new to rails and most of the people in

the class are also new to Ruby we teach

them rails and Ruby in a three day

course and they come out of that with a

pretty good foundation on how to do

programming in rails even though that

might be the first time they've seen

Ruby Ruby is not a hard language to pick

up so second story this is a true story

the other one was true too but I just

want to emphasize that this one in

particular is true the names have been

changed to protect the innocent guilty

those involved I was working in a large

financial company at the time and this

is soon after I've discovered Ruby and I

was using Ruby a lot again for my

tooling for the stuff I do every day I

wrote Ruby scripts to analyze the

database I Ruby scripts to go into the

database and pull out data and show it

to me in a form so I could easily figure

out what was going on in the database

I wrote Ruby scripts to talk to their

event manager so I could receive events

and publish events on their event

manager so everything in the environment

that we worked with

I had Ruby scripts to communicate with

that and make it easier as my job as a

programmer to do work in that

environment now this particular part of

the company dealt with incoming mail if

you send any kind of mail to this big

multinational financial corporation it

all came through this one room in Hebron

Kentucky and they would open up the mail

and they would scan it into a scanner

and digitize it that scanner that data

would go into a program that would read

it and it would generate an event for

every item that was

and that event was published and picked

up by the next program in the pipeline

so at this point it's been scanned it's

a form and it's got image data attached

to this event actually the image

restored the database but a reference to

the image was put into the event then it

would run through a barcode reader that

would look at the image and look for

barcodes and find data encoded on the

form in barcodes and add that to the

event and publish it again with this new

event then went to the checkbox analyzer

and it would look for check boxes on the

form and see if this check box was

checked or if this check box was not

checked and then it would add

information about check boxes to the

event and it would publish it again and

then they would go onto the pipeline

there were stages in this pipeline that

looked for character information did

handwriting analysis and there was

manual verification steps and things but

it kept publishing these events on the

pipeline till eventually got to the

point where it says okay we've collected

all the data for this form I'm going to

publish this data out to the pension

division or to the stock options

division or to some other division it

was a whole workflow type of thing well

for many years how they handled fax data

was they would get a fax they would

print out the fax and they would scan it

it that actually worked and surprisingly

but it seemed to be rather inefficient

and scanning a you know a fax is already

scanned and scanning that is just leads

to all kind of dirty images so they

thought they could get better results by

feeding the scan fax data directly into

the feed so the fax data would come into

its own process it would publish an

event and then it would enter the

pipeline just like anything else so

paper email our paper mail was scanned

fax data was scanned and sent in as well

so that's the way that worked I was

sitting at my desk one day working hard

on you know kind of heads down on

working of whatever I needed to work on

this was the days before pair

programming got popular so I had my own

cubicle right there and I was kind heads

down and I noticed that people were kind

of

wandering around outside my cubicle and

kind of running back and forth and and

the noise levels seem to be a bit little

bit louder and I wondered hmm

something's going on today and I don't

know what that might be but I'm working

here

and finally my manager comes into my

cubicle with another developer he says

uh Jim you know you know Ruby don't you

I said yeah because I've been kind of

evangelizing Ruby to the rest of the

group I was the main user of it but

there are several other people who saw

some of the advantage of Ruby and we're

using it as well and they said well this

is what happened be part of our process

that takes in facts and publishes the

event somehow was dropping events I no

longer recall the exact technical reason

for this failure maybe the disk was full

or maybe there is a section being thrown

I don't remember but these faxes were

being dropped now you know if I lose a

fax you know well how do I use fact I

fax order to our restaurant if I lose my

fax I don't get my meal that day that's

not the case with this company those

orders coming in might be changes to

pension plans are changes to stocks you

know buy the stock sell that stock and

if they don't take action on that order

within a certain number of hours they

are liable for the difference in price

from the point that they set the fax was

sent and the point they actually made

the trade this is potentially millions

of dollars of data that was falling out

of the fax machine and onto the floor

this was an emergency so they said Jim

you know Ruby can you help us now it

turns out that the facts program wrote a

pretty complete log of everything it did

and the log was still being written it

was saying oh except Shinzon we're not

delivering the message but every single

facts element was was recorded in the

log along with the database ID of the

image associated with that fax so what I

had to do was write a ruby script that

would read the log

would reconstruct the event based upon

details in the log pull the database ID

out and put it in an event and republish

that event into the system so

essentially I was writing a vacuum

sweeper that would sweep up all the

broken faxes laying on the floor and put

them in so this is how I saved the

company millions of dollars using Ruby

Ruby hero I asked for a fraction of that

million to be included in my bonus and

they just laughed I don't I don't get

that

and actually truthfully it was a team

effort I was doing the log recovery

someone else was doing some event stuff

there were about five or six people all

working on this problem the log recovery

piece was just a small portion of that

but together by using room in it and

they knew that Ruby could handle the job

they knew they could not write this

stuff in Java quick enough you know in

the half hour that we needed to get this

done so here Ruby handles an emergency

it's really rapid to get a quick

solution up it took me about half an

hour to figure out how to parse the log

file and generate those events and we

saved lots and lots of money with that

all right

next story I love this picture this is

actually at the Breedlove guitar Factory

in Bend Oregon and the gal here is

actually working on the fretboard of a

guitar she's playing in the grooves and

putting in the frets

for a guitar that will be made there I

have a Breedlove guitar so when I took

tour of the factory I just took all

kinds of pictures I love I love this

stuff but what I want to concentrate on

is that we as developers love to make

things love to build things I was

working on a project with a friend of

mine we were actually pairing and we

were working on getting a build script

up and running and working and we were

doing and we were it was for Java but we

were old hat developers back in those

days we this ant thing was kind of

newfangled for us so we were still using

make at the time and we were trying to

do make trying to get make to do

something that was just a little bit too

dynamic for make we were shelling out to

Ock and scripting stuff and doing all

kinds of weird things I think I look

like this by the time I was done I

turned around to Ryan I said Ryan

wouldn't it be great if make were

written in Ruby and Ryan says Jim that's

an awesome idea I have no idea what you

mean so I turned around to the

whiteboard and I scribbled on the

whiteboard something that looked

approximately like this I said Ryan you

would you would have a task command and

this task command takes a name of some

kind of task you want to perform and

then you just give it a block of stuff

you wish to execute when this task is

performed and somehow you would manage

dependencies and do that and and you

would just use this like you use make

but it'd be all written in Ruby it'd be

totally dynamic this problem that we're

trying to solve would be trivial to do

in Ruby and he says that's brilliant

and we talked about it for another five

minutes but then we realized no we

really really wanted to do this what

would we have to do well we would have

to reproduce the

entire functionality of make in Ruby

just so we can get it a little bit more

dynamic and we laughed at the idea

that's silly no one would ever ever want

to do that only an idiot so Ryan went

back to his desk and he left me sitting

there thinking and I began to think well

gosh how hard could it really be I mean

if I did a really trivial implementation

of make in Ruby thought what I have to

do he imagine you have this setup let's

set up a sample make make like problem

you have a task called make mac and

cheese and in order to make mac and

cheese you need to boil water you need

to buy cheese you need to buy the pasta

for the macaroni before you can buy

either pasta or macaroni you have to go

to the store and these tasks have to be

all be performed in the proper order

because you don't want to start boiling

the water before you go to the store

that would be silly so you need to have

some kind of dependency structure

between these tasks and you need to be

able to say hey go and do this so you

might create a structure that looks like

this

declare a task give it a list of

dependencies and these dependencies are

exactly the dependencies I've drawn out

here with the green arrows make mac and

cheese boil water buy pasta buy cheese

go to store five different tasks with

all their dependencies declared and if

you're familiar with rate this is very

very very similar to what rake looks

like today just a few syntactical

differences just to make it easy that's

what we're going to do now is we're

going to write rate

you think I'm joking so here there is

our task file I have it all ready to go

so there's all our tasks let's open up

the micro rake file and you can see it's

empty and what I want to be able to do

is be able say Ruby micro rake and give

it the Mac oh no excuse me make mac and

cheese command and run that and we'll

run all the tasks now you see it does

nothing here because our micro rake file

is empty so let's see what we need to

write to make this to work I'm going to

start with the last thing we do and work

backwards in the file so we need to be

able to grab this command name right

here this make mac and cheese from the

command line and try to invoke the task

to fix that so I'm going to say our V

each do for each argument in our

argument list we need to find the task

so let's assume we have a global hash

call tasks we look up the task in there

we invoke the task then we end so there

that's that's the end of our program so

what becomes before that what we need I

said I had a global task hash here so

let's create that and let's define a

task method it takes a name a thank you

in

we're just going to turn off Wi-Fi here

that is way too tempting for people

takes the name it takes dependencies and

it takes a block and in there we're

going to create a task object new and

pass it the name the dependencies and

the block into that that will create a

task object now I need to save it

somewhere so let's take our tasks hash

and save it by its name just like that

but what I wrote you twice oh oh thank

you this is why we pair this is like

super pairing or something okay so let's

create our cask

thing here and I'll need a constructor

takes the name the dependencies and the

action block and just stores them off

I'm going to want to have a method

called execute and execute is very

simple it just takes the action and

calls it because action is just a block

and it's going to it's an anonymous

function I'm just going to call it like

that and now I need to write invoke

voc's a little more tricky let's see a

task should never execute twice so if

it's already run lets you know you

invoke it it's already run we're done we

have to can return immediately so we

return if already yeah there we go

already run so if we get this far that

means it hasn't run yet we have to make

sure all our dependencies are invoked so

depths each do depth and I would like to

say DEP invoke but that's not quite

right because depth is the dependencies

are names so I have to look them

first so I have to look them up in the

tasks hash like that fortunately I have

that available and after all my

dependencies are invoked I can go ahead

and just execute our current task and

mark it as already run cool we're almost

done

the only thing we need to do is right

here we just need to require the tasks

file like that 28 lines of code let's

see how close I got a hard right i sat

down at my desk and I thought about this

I said this is easy actually I need a

list of dependencies I need to iterate

through them I need to evoke them

recursively and that's really all there

is so I took about half an hour I did

this in about three minutes took me

about half an hour the first time I did

this and I sat down and emailed it to

Ryan and then I really over - Ryan's

desk I said check your email check your

email check your email and he pulled it

up and there it was and I think it was I

think I had about 50 lines in my first

implementation there was 50 lines all of

you know the basic core logic of rape

right there and and Ryan glowed over it

he we were all and sincerely cool and

then I go but yeah but it's not really

make because make will check timestamps

on the files and only rebuild files if

they're out of date with respect to

their dependencies and this was more

like ant which just does tasks regularly

I thought yeah that file that file

testing thing that'd be hard no one

would ever do that I went back to my

desk and about 20 minutes later a

subclass task as a file task added a

check in there to see if it was out of

date was response with respect to its

dependencies and I had a file task of

singing there so whizzed in under an

hour's worth of coding I had the first

version of rake out there and running

now of course there's a lot more and

rake today there's file lists there's

there's all the shell commands that work

there's a lot of little things that help

you get rake like stuff done but this is

the core and this is it and it's all in

28 lines of code right there friend of

mine who was started using Ruby because

of my great enthusiasm for it he said

yeah Jim I was I tried to solve a

problem in Ruby the other day and I just

started writing code and I was done

before I realized it it's kind of how it

works Ruby is so good at expressing what

you as a programmer want to express it

really matches the way I think very

closely okay whoops that's skip I got

the code in there too so 28 lines of

code about half an hour of efforts you

got the basic core engine in there and

what we didn't do was file tasks this

was awesome this just goes to show that
Ruby is really good at expressing and
capturing ideas very quickly next story

we have to have speed up just a little

bit

beautiful testing or as I like to call

this section designed by conference I

was at the Ruby hoedown in 2009 do you

guys know what a hoedown is do you have

hoedowns here in earth way ask kind of a

southern thing in America right it's

kind of a party it's a dance it's a kind

of a you know good time party well the

Ruby hoedown was where we get together

and talk about Ruby and it's a it's a

lightweight conference it was free it's

close to where I live in Ohio and so a

lot of us from edge case we were edge

case of the time we would all pile in

about two or three vehicles and we drive

down to Nashville Tennessee where the

hoedown was being held and we all attend

a conference and this is almost kind of

like a little mini vacation for us here

you can see we're all gab this is at one

of the tables there at the hotel it

looks like we're in Florida because

there's palm

this is actually indoors in the hotel is

huge huge monsters hotel but during the

conference we sat around tables much

like this at the back room of the

conference area and we kind of talked

amongst each other because you know we

were kind of laid-back none of us were

presenting that year you were just

enjoying the conference and someone got

up to give a talk on cucumber how many

people use cucumber here anybody few I I

have a love-hate relationship with

cucumber but the thing I love about it

is the fact that lays out your testing

as given when and then I really really

really like that way of specifying my

test as these are the things that are

given when I do this code then I expect

this thing to happen and I would lay out

my tests in this format anyways kind of

informally but I was really looking for

a more formal way of specifying given

when then in my tests so I was sit in

the back room and I was taking all of

all this and I grabbed a notepad and I

started writing on the notepad notice

how so many ideas this kind of start as

scribbling down on a piece of paper and

I said I started pushing this paper

around the table where we were all

sitting I said does this make sense to

you if I if you saw a test in this

format would you understand what's going

on and the feedback I got was more or

less positive everybody felt that by

looking at something like this you could

kind of tell what was going even knowing

nothing about the given when them

framework you could figure out what was

going on so I would kind of got positive

feedback on this except for my boss

because at that time the test unit

versus many tests versus r-spec versus

something else flame wars were still

going strong and there were so many

testing frameworks for Ruby Joe really

didn't think we needed yet another one

and I assured him no Joe I am NOT going

to actually write this I'm just I'm just

brainstorming on ideas I lied so I wrote

a library called given that was based on

test unit and this is an example from

the github page is still out there don't

go and use it there's something better

than this but this is my first pass at

this and there's a couple things I'd

like to point out about this code first

of all I added the idea of an invariant

and invariant is something that is

always always always true no matter what

you do to this object in this case I'm

saying if you've got a stack object it

is always true that the stack depth is

going to be non-negative it's always

true that if the stack depth is zero

then empty will be true and if empty is

false then the stack depth will be

something other than zero these things

that are always true about a stack and

then I divided up the rest of test into

this I said given an empty stack and so

given this method so I had

initialization or setup procedures by

name you had to name that set up

procedures in the given statement and

then you went through several tests so

this is actually three tests right here

an empty stack the empty stack you

expect the stack to be 0 when you push

an item you expect the stack to the

depth to be 1 and the top to be that

item and when you pop it you should get

some kind of failure error now this was

ok I kind of liked it but I was a little

uncomfortable with it a couple things I

didn't like I didn't like this fails

with thing this was just pure ugly this

exception thing popped up by magic and

that was felt weird to me I didn't like

the fact I had to say expect expect

expect although I was doing this in

test unit I didn't have the dot should

that our spec uses I might have used

that here but I didn't like doing that a

whole lot so so it was okay but just not

quite what I wanted wanted the next year

I was at another conference this was

Ruby nation this takes place in the in

Washington deceived the capital of the

US there and at this conference John

Lahr Kowski was giving a talk on pure

r-spec

now at the time I was a test unit guy I

used test unit to write all my tests and

our spec was okay but I didn't use it

that much but he gave this talk r-spec

pure r-spec

in fact if you want to go see his talk

he's his slides are right there at that

URL and at one point he got to this

slide right here and he says our spec

has this thing called left if you say

let this name be this block left is a

lazy initializer when you call when you

reference that name the first time in a

test it goes out and execute that block

and assigns the value of the block is

the value for that name so here blog

post gets assigned a new blog post every

time it it gets referenced are the first

time it's referenced in a test if you

break this down it's essentially this

code that let statement is writing a

lazy initializer method that does this

well that was kind of cool

and I realized also that this really

interacts well with our specs block

nature you have nested describe and

context blocks in our spec and this

essentially turns into this where you

have a class here the left turns into a

method the example is here and so this

actually inherits from the outer

examples of this version overrides that

version so you can internally override

decisions you made outside and that

works really really nicely with the

structure of our spec so I rewrote our

spec or we were given to use our spec

and it turned out to be something like

this and I really really like the way

this this reads here we'll go through

fairly quickly so given a stack stack

new given the initial contents of the

sack and I felt Stu being empty the

initial contents and we load up the

stack with the initial contents here and

this given so here these Givens are

essentially let's this given here is

essentially a before I kept in variant

and notice there is no longer and expect

or should on that this returns either

true or false

and our spec given is able to determine

what the error is

if it fails and gives you a nice error

message we'll see you in a second here

is an empty stack with initial contents

that the staff does this when you push

these things are true when you pop it

should have failed so this is much like

the test we saw before here's a stack

with several items so we override the

initial contents to be this the original

depth we record and so after you you

know you do some pushing you do some

popping and these are the things that

are true once that's done this reads

beautifully this reads like a

specification this I love this I love

this and just about everyone I showed

this to says yeah this is kind of cool

they really really really liked it for

writing their their specs the nice thing

is suppose we change this to be a two so

this fails if you do that you get this

kind of error message where it tells you

we expected one to equal zero and then

it breaks down the expression that

failed it gives you the stack depth is

one the stack object is this the

original depth minus two is zero the

original depth itself is two so it

breaks down each sub expression in this

thing that failed and gives you all the

details you need to debug why that thing

is failing so beautiful output from a

beautiful testing framework so summary

sometimes ideas mature slowly there's

synergy in things like the nested nature

and the given run then of our spec and

you get expressive readable tests out of

this I'm almost out of time but we're

going to go real fast flying robots as

our last story this ties into

the video I put at the front so this is

the AR Drone that you saw flowing this

is in the outdoor mode where it doesn't

have the bumpers on it it has cameras it

has all kinds of sensors that allow it

to do interesting things and the best

part of it is that it talks to you over

Wi-Fi and the entire API is open and you

can see exactly what's going on and

there's a developer guides in PDF than

the entire API so it looks something

like this there's a command stream that

goes to the drone it sends back

navigation data and video data

navigation data looks something like

this you send a text command so it's

trivial to write this in Ruby you have

to send it a sequence number you send it

things like takeoff flags and emergency

landing flags you give it information

like roll and pitch and altitude and and

yaw you send all that information to it

you can send it configuration commands

like set your lights to be this hour do

some particular video targeting and

here's a program written in a library

called Argos it creates a drone object

starts it takes off turns right for five

seconds turns left for five seconds then

hovers and lands turn right for five

seconds to the left for five seconds

hovers and lands here's another one this

will take off and go through a loop go

left and right two times showing you the

code here just so you believe it's

program hit the return there's a

five-second delay I run over the other

side of the office this is me running

right left right left laying a hover and

land the first time I tried programmatic

control of moving sideways I said go

forward one and went room right into a

wall

okay maybe ones not the best let's do

point two so navigation coming back from

the drone is a lot trickier where the

stuff going to the drone is just simple

text commands coming back is actually

binary data it has a fixed length tenor

that's about four I think it's for

32-bit integers have come back at the

header this got variable length options

navigation data and vision detection

data are the two options that I'm

interested in particular and they're

variable lengths and they're packed and

they look like this

this is actually from the structure of

the C code from the API that means to

decode this stuff I've got to do weird

things like unpack it with weird

commands in the unpack command and then

know exactly which array element

references that particular data and then

they have to do like some floating point

D codes on the floating point data that

comes back and it's just weird so I

don't want to do that so I wrote some

code that looks like this this is Ruby

code that looks a lot like the C code

we're just missing we added a semicolon

at the beginning of the name and removed

the atom out of the colon to be getting

the name remove the semicolon and it is

now Ruby code so I can take the header

paste it in my Ruby do minor text

editing on it and now I have something

that allows me to access that data so

this line says unpack it with a capital

V and the name of that data position in

the array is V V bat flying percentage

the battery percentage left

this one says unpack it was V decoded

with the decode float command and then

call that one theta so I can do this

with all the options there here's I'm

going to skip over this this is not that

important but here's another program

that says when this is a callback and

this is called whenever the drone sends

me a binary data package and it says

okay go through the data options and for

each option check to see if it is the

nav option

vision detection so the drone tells me

when it sees a particular target in its

camera sights and tells me the position

in the camera where that is it's about a

thousand pixels wide so if we're at five

hundred we're on target if we're above

six hundred I want to turn right if it's

below 400 I want to turn left

so we blinked the lights we take off and

I'm going there I am holding the outdoor

hall and that orange and yellow pattern

is what the camera detects

too fast there we go okay move slow it

can find it it's not real bright okay so

there we go

and there we go so it's turning and

following the pattern we're doing some

more stuff with this we're not done with

this what I want to do is be able to

have it follow me put a hat with that

pattern on it and walk down the hall I

just have the drone follow me wherever

it goes

turns out that's a lot trickier than

just having it turn and look at you the

first time. 

I did it I had a bug in my advance you know advance or back up
logic and it zero difficulty a target  like just attacked me so we're going  slow in that part all right so summary.

this is real-time programming.

I have to send that drone come in I'll come in at
every 50 milliseconds or so just so it
doesn't lose the data stream otherwise
it will shut down and hover and land I'm
using threads although I want to switch

around to you celluloid and an actor

pattern in the near future there is a

library called r2 that allows you to

talk to multiple robotic type devices

one of them being the drone the another

being like us have you seen the sparrow

robots the round robots that are colored

and just roll around you can control

those with the r2 library so check that

one out

this library I'm using to control the

drone itself is called Argus yeah so

again being able to write expressive

code I could take that C code put it in

my Ruby code and exactly map to the

exact data that was in that binary data

and doggone it this stuff is fun so

features and benefits you saw some of

the features but the benefits of Ruby

that I see it's easy to learn you can be

up and running on Ruby really really

quickly it's extremely expressive it

says what you want to say in your code

it's flexible you can write it you can

they'll see data structures with it you

can get to a working prototype really

really fast with it it's easy to change

and doggone it I think Ruby is fun I'm

out of time but I'm jhamora cat Neil

thank

